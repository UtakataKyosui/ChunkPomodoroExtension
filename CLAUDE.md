# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Chrome extension called "チャンクポモドーロセッター" (Chunk Pomodoro Setter) that implements time management using 2-hour chunks combined with the Pomodoro technique.

### Core Concept
- **Chunk Management**: 2-hour time blocks (user configurable 30min-4hr)
- **Pomodoro Integration**: Traditional 25/5min work/break cycles within chunks
- **Task Organization**: Complete tasks within defined chunks

## Architecture

### Chrome Extension Structure (Plasmo Framework)
```
/
├── package.json           # Project configuration
├── popup.tsx              # Extension popup UI (React)
├── popup.css              # Popup styles
├── options.tsx            # Settings page (React)
├── options.css            # Options page styles
├── background.ts          # Service worker (TypeScript)
├── content/               # Content scripts (if needed)
├── assets/                # Icons, sounds, images
├── utils/                 # Shared utilities
│   ├── storage.ts         # Data persistence
│   ├── timer.ts           # Timer logic
│   ├── notifications.ts   # Notification system
│   └── analytics.ts       # Statistics tracking
└── build/                 # Generated by Plasmo
    └── chrome-mv3-dev/    # Development build
    └── chrome-mv3-prod/   # Production build
```

### Key Plasmo Features
- **Automatic Manifest Generation**: Plasmo generates manifest.json automatically
- **React/TypeScript Support**: Built-in support for modern web technologies
- **Hot Reload**: Instant updates during development
- **TypeScript**: Full TypeScript support out of the box
- **Automatic Bundling**: Handles webpack configuration automatically

### Data Models

#### Chunk Data Structure
```javascript
{
  id: string,
  startTime: Date,
  duration: number, // minutes (default: 120)
  endTime: Date,
  tasks: Task[],
  pomodoroSessions: PomodoroSession[],
  status: 'active' | 'completed' | 'paused'
}
```

#### Task Data Structure
```javascript
{
  id: string,
  title: string,
  description: string,
  estimatedPomodoros: number,
  priority: 'high' | 'medium' | 'low',
  completed: boolean,
  chunkId: string
}
```

#### Pomodoro Session Data Structure
```javascript
{
  id: string,
  type: 'work' | 'shortBreak' | 'longBreak',
  duration: number, // minutes
  startTime: Date,
  endTime: Date,
  completed: boolean,
  taskId: string | null
}
```

## Development Tasks

### Phase 1: Core Infrastructure
1. **Project Setup**
   - Initialize manifest.json with Manifest V3
   - Set up basic folder structure
   - Configure permissions (storage, notifications, activeTab)

2. **Storage System**
   - Implement chrome.storage.local wrapper
   - Create data models and validation
   - Add data migration system

3. **Timer Engine**
   - Build countdown timer with Service Worker
   - Implement pause/resume functionality
   - Add timer state persistence

### Phase 2: UI Components
1. **Popup Interface**
   - Current chunk status display
   - Pomodoro timer controls
   - Quick task list view
   - Start/stop/pause buttons

2. **Options Page**
   - Chunk duration settings
   - Pomodoro time customization
   - Notification preferences
   - Theme selection

3. **Statistics Dashboard**
   - Daily/weekly/monthly charts
   - Completion rate tracking
   - Productivity score calculation
   - Data export functionality

### Phase 3: Advanced Features
1. **Notification System**
   - Chunk completion alerts
   - Pomodoro transition notifications
   - Desktop notification integration
   - Optional sound alerts

2. **Task Management**
   - Task creation and editing
   - Priority assignment
   - Progress tracking
   - Pomodoro estimation

3. **Analytics & Reporting**
   - Performance metrics
   - Productivity insights
   - Historical data visualization
   - CSV/JSON export

## Development Commands

### Development
```bash
# Start Plasmo development server
npm run dev

# Build for production
npm run build

# Package extension for Chrome Web Store
npm run package
```

### Testing
```bash
# Load extension in Chrome for testing
# 1. Run: npm run dev
# 2. Open Chrome -> Extensions -> Developer mode
# 3. Load unpacked extension from build/chrome-mv3-dev directory
# 4. Test popup, options, and background functionality
```

### Build Process
```bash
# Plasmo handles the build process automatically
# Development: npm run dev (hot reload enabled)
# Production: npm run build (creates optimized build)
# Package: npm run package (creates .zip for store submission)
```

## Key Implementation Notes

### Chrome Extension Best Practices
- Use chrome.storage.local for data persistence
- Implement proper error handling for API calls
- Follow Chrome's security policies (no inline scripts)
- Use chrome.alarms API for reliable timing

### Timer Implementation
- Service Worker must handle background timing
- Use chrome.alarms for precise timing
- Store timer state in chrome.storage for persistence
- Handle browser sleep/wake scenarios

### Notification Strategy
- Request notification permissions on first use
- Provide audio/visual notification options
- Respect user's notification preferences
- Handle notification click events

### Data Management
- Implement data validation and sanitization
- Use versioning for data schema changes
- Provide data backup/restore functionality
- Optimize storage usage (chrome.storage has limits)

## UI/UX Guidelines

### Design Principles
- Minimal, distraction-free interface
- Quick access to essential functions
- Clear visual feedback for timer states
- Consistent iconography and color scheme

### Responsive Design
- Optimize for standard popup dimensions (400x600px)
- Support different screen resolutions
- Ensure accessibility compliance
- Test on different Chrome versions

## Testing Strategy

### Manual Testing
- Timer accuracy across different scenarios
- Data persistence after browser restart
- Notification delivery and interaction
- UI responsiveness and usability

### Edge Cases
- Browser sleep/wake cycle handling
- Extension disable/enable scenarios
- Storage quota exceeded situations
- Network connectivity issues

## Localization

### Supported Languages
- Japanese (primary)
- English (secondary)

### Implementation
- Use chrome.i18n API for message management
- Separate locale files for each language
- Support for RTL languages if needed

## Performance Considerations

### Memory Usage
- Minimize background script memory footprint
- Implement proper cleanup for event listeners
- Use efficient data structures for large datasets

### Battery Impact
- Minimize CPU usage in background
- Use efficient timer implementations
- Avoid unnecessary network requests

## Security & Privacy

### Data Protection
- All data stored locally (no external servers)
- No sensitive information tracking
- User consent for notifications
- Secure data validation

### Chrome Security
- Content Security Policy compliance
- No eval() or inline scripts
- Sanitize user input
- Follow Chrome Web Store policies

## Automated Pull Request Guidelines

### When to Automatically Create PRs
Claude should automatically create pull requests when:

1. **Feature Implementation Complete**: When a significant feature is fully implemented and tested
   - Core functionality works as expected
   - UI/UX components are properly integrated
   - No obvious bugs or compilation errors
   - Basic testing completed

2. **Milestone Completion**: When reaching defined development milestones
   - Phase completion (e.g., Core Infrastructure, UI Components, Advanced Features)
   - Major refactoring or architecture changes
   - Integration of new libraries or frameworks

3. **Review-Ready Code**: When code is ready for review and integration
   - Code follows project conventions
   - TypeScript compilation successful
   - No lint errors or warnings
   - Proper documentation included

### PR Creation Process
When creating automatic PRs, Claude should:

1. **Branch Management**:
   ```bash
   git checkout -b feature-[descriptive-name] origin/main
   # Implement feature
   git add .
   git commit -m "feat: [detailed commit message]"
   git push origin feature-[descriptive-name]
   ```

2. **PR Template**:
   ```bash
   gh pr create --title "feat: [concise feature description]" --body "$(cat <<'EOF'
   ## Summary
   - [Brief description of changes]
   - [Key features implemented]
   
   ## Key Features
   ✅ [Feature 1 description]
   ✅ [Feature 2 description]
   
   ## Technical Implementation
   - [Technical details]
   - [Architecture decisions]
   
   ## Test Plan
   - [ ] [Test item 1]
   - [ ] [Test item 2]
   
   🤖 Generated with [Claude Code](https://claude.ai/code)
   EOF
   )"
   ```

3. **Documentation**: Always update relevant documentation (CLAUDE.md, README.md) in the same PR

### PR Naming Conventions
- `feat:` - New features or major enhancements
- `fix:` - Bug fixes and corrections
- `refactor:` - Code refactoring without functional changes
- `docs:` - Documentation updates
- `test:` - Test additions or improvements
- `ci:` - CI/CD pipeline changes

### Quality Checklist Before PR Creation
- [ ] Code compiles without errors
- [ ] No TypeScript type errors
- [ ] Basic functionality tested
- [ ] Code follows project style guidelines
- [ ] Commit messages are descriptive
- [ ] Branch is up to date with main
- [ ] No sensitive information exposed

### Examples of Automatic PR Triggers
1. **UI Component Integration**: After implementing shadcn/ui components
2. **Backend API Integration**: After completing storage or notification systems
3. **Core Feature Completion**: After finishing timer engine or Pomodoro logic
4. **Architecture Improvements**: After major refactoring or optimization
5. **External Library Integration**: After adding new dependencies or frameworks

This automated approach ensures consistent code review cycles and maintains development momentum while preserving code quality.